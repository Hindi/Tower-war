using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Zone : MonoBehaviour {

    [SerializeField]
    private GameObject tilePrefab;

    private Dictionary<int, Tile> tileDict;
    public Dictionary<int, Tile> TileDict
    {
        get { return tileDict; }
    }

    private GameObject startTile;
    public GameObject StartTile
    {
        get { return startTile; }
        set { startTile = value; }
    }

    private GameObject endTile;
    public GameObject EndTile
    {
        get { return endTile; }
        set { endTile = value; }
    }

	// Use this for initialization
	void Start () {
        tileDict = new Dictionary<int, Tile>();

        //Calculate the dimension that we'll use
        float width = 0;
        float height = 0;
        float offestW;
        float offsetL = 0;

        GameObject currentTile = null;
        Tile currTileScript;
        for (int j = 0; j < 20; ++j)
        {
            for (int i = 0; i < 10; ++i)
            {
                currentTile = (GameObject)Instantiate(tilePrefab);
                currTileScript = currentTile.GetComponent<Tile>();
                Rect rect = currentTile.GetComponent<SpriteSwitcher>().CurrentSprite.rect;

                width = rect.width / 100;
                height = rect.height / 84;
                offestW = width / 2;
                currentTile.transform.position = new Vector3(offsetL + i * (width + offestW), j * height / 2.4f, 0);
                currTileScript.Zone = this;
                currTileScript.calcId();

                tileDict.Add(currTileScript.Id, currTileScript);
                if (i == 0 && j == 0)
                {
                    GetComponent<CreepSpawner>().StartTile = currentTile;
                    StartTile = currentTile;
                }
            }
            if (offsetL == 0)
                offsetL = width * 2 / 2.69f;
            else
                offsetL = 0;
        }
        GetComponent<CreepSpawner>().EndTile = currentTile;
        EndTile = currentTile;

        foreach (KeyValuePair<int, Tile> p in tileDict)
            p.Value.catchNeighboursIds();
	}
	
	// Update is called once per frame
	void Update () {
	
	}

    public void notifyMouseOver()
    {
        foreach (Transform g in transform)
        {
            g.GetComponent<Fader>().setRendererVisible(true);
        }
    }

    public void notifyMouseExit()
    {
        foreach(Transform g in transform)
        {
            g.GetComponent<Fader>().setRendererVisible(false);
        }
    }

    public bool canBuildHere(Tile tile)
    {
        return GetComponent<Pathfinder>().canAddObstacle(tile);
    }
}
